*commentr.txt*	For Vim version 7.3

                                      Type |gO| to see the table of contents.

==============================================================================
INTRO							*commentr-intro*

A powerful commenter plugin.

==============================================================================
COMMANDS						*commentr-commands*

:[range]Comment	[flags]						*:Comment*
			Comment a range of text.
			Range is automagically calculated from current mode.

			|mode()|	range
			n		The given [range]. Note that if no
					explicit range is given Vim uses '.'
					as default, i.e.  the line the under
					cursor.

			no		The motion. (Don't use it directly.)

			v, V, CTRL-V
			s, S, CTRL-S	Selected range from '[ to '].

			i		A zero-length range at the position of
					the cursor

			Calling in every other mode is an error.

			Example: >
				map {binding} <Cmd>Comment<CR>
				map {binding} <Cmd>Uncomment<CR>
<				Calculates region from current mode.

			For flags see |commentr-flags|.

:[range]Uncomment						*:Uncomment*
			Uncomment a range of text.
			See |:Comment| for how range is calculated.

:[range]UncommentLines					*:UncommentLines*
			Same as |:Uncomment|, but force linewise mode.
			See |:Comment| for how range is calculated.

:[range]ToggleComment	[flags]					*:ToggleComment*
			If the text under the cursor is uncommented sam as
			|:Comment| otherwise |:Uncomment| .
			For more see |:Comment| .


List of funtions:					*commentr-functions*

commentr#CommentMotion({flags})			*commentr#CommentMotion()*
		Can be used to comment text over motion. This way |:Comment|
		will be called in |Operator-pending-mode|. Using together with
		|:map-<expr>|, it's a convenient way to specify commenting over
		predefined motions.  Example: >
			nmap <expr> gc; commentr#CommentMotion('') . 'f;'
<		comments out line to the next ";". >
			map <expr> gcc
			  \ '_' . commentr#CommentMotion({flags}) . '$'
<		Comment out current line, starting from the first non-white
		character.

commentr#UncommentMotion({flags})			*commentr#CommentMotion()*
		Same as |commentr#CommentMotion()|, but it calls |:Uncomment|.

commentr#ToggleCommentMotion({flags})	*commentr#ToggleCommentMotion()*
		Same as |commentr#CommentMotion()|, but it calls |:ToggleComment|.

==============================================================================
CONFIGURATION					*commentr-configuration*

------------------------------------------------------------------------------
Filetype guessing					*commentr_ft_noguess*
							*g:commentr_ft_noguess*

Specifies filetypes to disable filetype guesses. Values can be a {List} of
filetypes or "*" to disable all kind of guesses.

Example: >
	let g:commentr_ft_noguess = { 'c': ['cpp'] }
<	When 'filetype' is "c", disable "cpp" guesses. It's needed because
	"cpp" uses syntax items from "c", so this way commentr would guess
	that currently "cpp" code is edited inside "c". It can cause issues
	when using C89 where there are no "//" comments. >
	let g:commentr_ft_noguess = { 'html': '*' }
<	Only use "html" comments inside a "html" file. Don't try to guess
	based on syntax.

------------------------------------------------------------------------------
Comment margin						*commentr_margin*
							*g:commentr_margin*
							*b:commentr_margin*

Margin around comments. It can be a {Number} or a {Dictionary} that specifies
margin to being used per "group".

>
	let g:commentr_margin = 3;

	     [<->]           [<->]
	Lorem     /* ispum */     dolor
<
------------------------------------------------------------------------------
Comment padding						*commentr_padding*
							*g:commentr_padding*
							*b:commentr_padding*

Padding inside comments. It can be a {Number} or a {Dictionary} that specifies
padding to being used per "group".

Examples: >
	let g:commentr_margin = { '': 1, 'd': 0, 'default': 5 }

	            [<->]       [<->]
	Lorem /*      ispum      */ dolor
<
------------------------------------------------------------------------------
Comment alignment					*commentr_align*
							*g:commentr_align*
							*b:commentr_align*

Specifies how to align left and right parts of the comment string in a line.
It's a {String} in the format of "{left}{right}" where {left} and {right} is a
specifier from |commentr_align-left| and |commentr_align-right| respectively.
Default is "|$".

Note that <Tab> charaters will be split into spaces where necessary.

	{left}	meaning					*commentr_align-left*
	0	Place left part of comment to the first column.
>
		 1|>   struct foobar {
		 2|>    field1,
		 3|>      field1,
		 4|>   }

	_	Place left part of comment before the first non-white
		character.
>
		 1|   >struct foobar {
		 2|    >field1,
		 3|      >field1,
		 4|   >}
<
	|	Place left part of comment to one column and as right as
		possible.
>
		 1|   >struct foobar {
		 2|   > field1,
		 3|   >   field1,
		 4|   >}
<
	{right}	meaning					*commentr_align-right*
	$	Append right part of comment to the line.
>
		(assume trailing whites)

		 1|   struct foobar {    <
		 2|    field1,  <
		 3|      field1, <
		 4|   }   <
<
	<	Same as $, but remove trailing whites.
>
		 1|   struct foobar {<
		 2|    field1,<
		 3|      field1,<
		 4|   }<
<
	|	Remove trailing whites and place right part of comment to one
		column and as left as possible. Note that lines may be longer
		than 'textwidth'.
>
		 1|   struct foobar {<
		 2|    field1,       <
		 3|      field1,     <
		 4|   }              <
<
	I, >	Remove trailing whites and stretch line to 'textwidth'
		character wide by inserting spaces. When no 'textwidth' is
		specified, ">" is the same as "|", "I" is the same as "$".
>
		set &textwidth=15

		   |-------------|
		  |12345678901234567890
		 1|   struct foobar {<
		 2|    field1,   <
		 3|      field1, <
		 4|   }          <
<

------------------------------------------------------------------------------
Disable default bindings				*commentr_no_mappings*
							*g:commentr_no_mappings*

1 to disable builtin mappings, otherwise enable.

See |commentr_bindings|, for customizing builtin mappings, or
|commentr-commands| and |commentr-functions| for how to add custom mappings.

------------------------------------------------------------------------------
Default bindings					*g:commentr_bindings*

Used for mapping a specific keybinding fragment to a commenting flag. It is a
{Dictionary} that contains items in the format of "binding": "flags". See
|commentr-flags| for what "flags" can be. "binding" can be any {String} that
specifies a valid key combination. It will be used in the following format for
adding builtin mappings: "<Plug>(CommentrComment){binding}".

Examples: >
	{ 'c': '', 'cm': 'm', 'cd': 'DDD' }
	{ 'c': '', 'ct': 'a' }
<

List of plugin keys:				*commentr-builtin-keys*

<Plug>(CommentrComment)
	Used for toggling comments.

<Plug>(CommentrUncomment)
	Used for

Example: >
	nmap gc <Plug>(CommentrComment)
	nmap gcu <Plug>(CommentrUncomment)
<	Change prefix of default mappings only in normal mode.

List of builtin mappings			*commentr-builtin-mappings*

If |commentr_no_mappings| is not enabled the following mappings will be used.

Normal mode mappings:

<Plug>(CommentrComment)<binding>{motion}
	Toggle comment on text moved over by {motion}.
	Note that every top-level comments will be removed even if its end is
	after {motion}.

<Plug>(CommentrComment)<binding>c
	Toggle comment on current line. It can be treated as a shortcut to
	"_<Plug>(CommentrComment)$" but uses internal alignment specifiers
	from |commentr_align| instead of jumping with "_" and "$" to position
	parts of the comment.

<Plug>(CommentrComment)<binding>A
	Jump with |A| and insert comment, i.e. append comment.

<Plug>(CommentrComment)<binding>I
	Jump with |I| and insert comment, i.e. prepend comment.

<Plug>(CommentrComment)<binding>o
	Jump with |o| and insert comment, i.e. insert comment below.

<Plug>(CommentrComment)<binding>O
	Jump with |O| and insert comment, i.e. insert comment above.

<Plug>(CommentrComment)C{motion}
	Comment out lines moved over by {motion}.
	Note: It is only defined for default comment group.

<Plug>(CommentrComment)x
	Toggle so called "sexy" comments.

<Plug>(CommentrUncomment){motion}
	Uncomment lines moved over {motion}

<Plug>(CommentrUncomment)u
	Uncomment current line.

Visual mode mappings:

<Plug>(CommentrComment)<group>c
	Comment out regin.

<Plug>(CommentrUncomment)
	Uncomment region.

Insert mode mappings:

<Plug>(CommentrComment)<group>i
	Insert comment at the place of the cursor.

==============================================================================
CONCEPTS						*commentr-concepts*

------------------------------------------------------------------------------
Comment groups						*commentr-comment-group*

Comment group is a single letter [a-z]. In contexts where it can be omitted,
it defaults to "c". It is the default group.

Conventionally "d" is used for documentation comments and "m" for module
comments.

------------------------------------------------------------------------------
Comment flags					*commentr-flags*

Controls commenting and uncommenting flags. It can be composed from the
combination of the following letters:

  >	Allow middle part of a three-piece comment if available. Default is to
  	disable. See 'comments' for middle pieces.
  >
{group}:
  {[a-z]}
	Specifies a group to used for commenting and uncommenting.

  {[A-Z]}
	Specifies a group to used for commenting and uncommenting.


If group is not specified, it defaults to the default group, that is the same
as "c". So forcing linewise commenting with using the default group, use "C".

------------------------------------------------------------------------------
Comment string					*commentr-comment-string*

It is just like 'commentstring' with some added features. It is a
comma-separated list of commenting alternatives. Each alternative consits of:
	[{flags}...][{lalign}]{format}[{ralign}][,,{transform}...]

{flags}:
  \=x	Group to be use for the current and further
	comments. Internally, "\=d" used for documentation and
	"\=m" for module comments.

{lalign}:
  \0 \^ Comment must begin on the first column.

  \_	Comment must begin on the first non-whitespace column.

{format}:
	Format of comment. "%s" will be replaced with the
	comment text. If omitted, format will be treated like if "%s" would be
	appended to the end of the value.

{ralign}:
  \$	Comment must end at the last column. If right part of comment string
	is empty, it specifies a line comment.

  \_	Comment must end at the last non-whitespace column,
	i.e. optional whitespace can follow it.  For formats without right
	sides (e.g "//%s"), it defaults to "\$", otherwise no requirements
	will be specified.

{transform}:
  x/{sub1}/{sub2}/
	Swaps {sub1} and {sub2}: Substitutes {sub1}
	with {sub2} when commenting, and {sub2} with {sub1} when uncommenting.
	{sub1} and {sub2} are "\" escaped and passed to the regex engine with
	'noignorecase' and "very nomagic" flags ("\C\V").

  s/{pat}/{sub}/
	Substitute {pat} with {sub} only when commenting.

  S/{pat}/{sub}/
	Substitute {pat} with {sub} only when uncommenting.

Optional whitespace can be inserted between {transform} sequences. Any other
character can be used as a separator instead of "/" in {transform}.

Examples: >
	\=d\_<<%s>>\_,,  x|>>|AA|
<	Specifies a documentation comment that must spawn through the whole
	line with optional whitespace surrounding it. When commenting, every
	occurence of ">>" will be replaced with "AA". On uncommenting it will
	be undoed.

	Note that for one-way transformation use "s" or "S". It can be
	used to build regexes to nest unnestable comments.

See "autoload/commentr.vim" for more examples.

==============================================================================
CONTRIBUTIONS					*commentr-contributions*

Contributions and pull requests are welcome.

==============================================================================
LICENSE							*commentr-license*

Released under the GNU General Public License version v3.0 or later.

 vim:noet:tw=78:ts=8:ft=help:norl:nowrap
