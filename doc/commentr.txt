*commentr.txt*	For Vim version 7.3

                                      Type |gO| to see the table of contents.

==============================================================================
INTRO							*commentr-intro*

A powerful commenter plugin.

==============================================================================
COMMANDS						*commentr-commands*

:[range]Comment	[flags]						*:Comment*
			Comment a range of text.
			Range is automagically calculated from current mode.

			|mode()|	range
			n		The given [range]. Note that if no
					explicit range is given Vim uses '.'
					as default, i.e.  the line the under
					cursor.

			no		The motion. (Don't use it directly.)

			v, V, CTRL-V
			s, S, CTRL-S	Selected range from '[ to '].

			i		A zero-length range at the position of
					the cursor

			Calling in every other mode is an error.

			Example: >
				map {binding} <Cmd>Comment<CR>
				map {binding} <Cmd>Uncomment<CR>
<				Calculates region from current mode.

			For flags see |commentr-flags|.

:[range]Uncomment						*:Uncomment*
			Uncomment a range of text.
			See |:Comment| for how range is calculated.

:[range]UncommentLines					*:UncommentLines*
			Same as |:Uncomment|, but force linewise mode.
			See |:Comment| for how range is calculated.

:[range]ToggleComment	[flags]					*:ToggleComment*
			If the text under the cursor is uncommented sam as
			|:Comment| otherwise |:Uncomment|. Determining whether
			a text is commented is based on syntax item under and
			around cursor.
			For more see |:Comment|.


List of funtions:					*commentr-functions*

commentr#CommentMotion({flags})			*commentr#CommentMotion()*
		Can be used to comment text over motion. This way |:Comment|
		will be called in |Operator-pending-mode|. Using together with
		|:map-<expr>|, it's a convenient way to specify commenting over
		predefined motions.  Example: >
			nmap <expr> gc; commentr#CommentMotion('') . 'f;'
<		comments out line to the next ";". >
			map <expr> gcc
			  \ '_' . commentr#CommentMotion({flags}) . '$'
<		Comment out current line, starting from the first non-white
		character.

commentr#UncommentMotion({flags})			*commentr#CommentMotion()*
		Same as |commentr#CommentMotion()|, but it calls |:Uncomment|.

commentr#ToggleCommentMotion({flags})	*commentr#ToggleCommentMotion()*
		Same as |commentr#CommentMotion()|, but it calls |:ToggleComment|.

==============================================================================
CONFIGURATION					*commentr-configuration*

------------------------------------------------------------------------------
Custom commentstrings				*g:commentr_commentstrings*

Mapping between 'filetype's and |commentr-comment-string|s. Expects a
{Dictionary}. If an empty value is specified, filetype will be removed from
internal lookup table.

Example: >
	let g:commentr_commentstrings = { "x": "", "c": "//*/%s" }
<	Only use standard 'commentstring' and 'comment' for filetype "x".
	Change commentstring for "c".

------------------------------------------------------------------------------
Filetype guessing					*commentr_ft_noguess*
							*g:commentr_ft_noguess*

Specifies filetypes to disable filetype guesses. Values can be a {List} of
filetypes or "*" to disable all kind of guesses.

Example: >
	let g:commentr_ft_noguess = { 'c': ['cpp'] }
<	When 'filetype' is "c", disable "cpp" guesses. It's needed because
	"cpp" uses syntax items from "c", so this way commentr would guess
	that currently "cpp" code is edited inside "c". It can cause issues
	when using C89 where there are no "//" comments. >
	let g:commentr_ft_noguess = { 'html': '*' }
<	Only use "html" comments inside a "html" file. Don't try to guess
	based on syntax.

------------------------------------------------------------------------------
Disable default bindings				*commentr_no_mappings*
							*g:commentr_no_mappings*

1 to disable builtin mappings, otherwise enable.

See |commentr_bindings|, for customizing builtin mappings, or
|commentr-commands| and |commentr-functions| for how to add custom mappings.

------------------------------------------------------------------------------
Default bindings					*g:commentr_bindings*

Used for mapping a specific keybinding fragment to a commenting flag. It is a
{Dictionary} that contains items in the format of "binding": "flags". See
|commentr-flags| for what "flags" can be. "binding" can be any {String} that
specifies a valid key combination. It will be used in the following format for
adding builtin mappings: "<Plug>(CommentrComment){binding}".

Examples: >
	{ 'c': '', 'cm': 'm', 'cd': 'DDD' }
	{ 'c': '', 'ct': 'a' }
<
List of plugin keys:				*commentr-builtin-keys*

<Plug>(CommentrComment)
	Used for toggling comments.

<Plug>(CommentrUncomment)
	Used for

Example: >
	nmap gc <Plug>(CommentrComment)
	nmap gcu <Plug>(CommentrUncomment)
<	Change prefix of default mappings only in normal mode.

List of builtin mappings			*commentr-builtin-mappings*

If |commentr_no_mappings| is not enabled the following mappings will be used.

Normal mode mappings:

<Plug>(CommentrComment)<binding>{motion}
	Toggle comment on text moved over by {motion}.
	Note that every top-level comments will be removed even if its end is
	after {motion}.

<Plug>(CommentrComment)<binding>c
	Toggle comment on current line. It can be treated as a shortcut to
	"_<Plug>(CommentrComment)$" but uses internal alignment specifiers
	from |commentr_align| instead of jumping with "_" and "$" to position
	parts of the comment.

<Plug>(CommentrComment)<binding>A
	Jump with |A| and insert comment, i.e. append comment.

<Plug>(CommentrComment)<binding>I
	Jump with |I| and insert comment, i.e. prepend comment.

<Plug>(CommentrComment)<binding>o
	Jump with |o| and insert comment, i.e. insert comment below.

<Plug>(CommentrComment)<binding>O
	Jump with |O| and insert comment, i.e. insert comment above.

<Plug>(CommentrComment)C{motion}
	Comment out lines moved over by {motion}.
	Note: It is only defined for default comment group.

<Plug>(CommentrComment)x
	Toggle so called "sexy" comments.

<Plug>(CommentrUncomment){motion}
	Uncomment lines moved over {motion}

<Plug>(CommentrUncomment)u
	Uncomment current line.

Visual mode mappings:

<Plug>(CommentrComment)<group>c
	Comment out regin.

<Plug>(CommentrUncomment)
	Uncomment region.

Insert mode mappings:

<Plug>(CommentrComment)<group>i
	Insert comment at the place of the cursor.

==============================================================================
CONCEPTS						*commentr-concepts*

------------------------------------------------------------------------------
Comment flags					*commentr-flags*
						*g:commentr_default_flags*

Controls commenting and uncommenting options. It's one-line string that
composed from the combination of the following letters. Every flag is
optional. Default values come from |g:commentr_default_flags|, otherwise 0 or
empty string will be used, based on the nature of the option.

{group}:
  {[a-z]}
	Specifies a group to used for commenting and uncommenting.
  {[A-Z]}
	Specifies a group to used for commenting and uncommenting. Force
	linewise mode.
  *	All groups.

	Comment group is a single letter [a-z]. In contexts where it can be
	omitted, it defaults to "c". It is the default group.

	Conventionally "d" is used for documentation comments and "m" for
	module comments.

  =	Force linewise mode.

  +{left-align}{left-margin}[{left-padding}
  {right-padding}]{right-margin}{right-align}+
	Specifies alignment, margins and paddings for left and right end of
	comments respectively. Margins and paddings are {Number}

	"+" signs allow middle parts of a three-piece comment on the left and
	right sides. Disallowed by default. See 'comments' for left middle
	pieces.

	Text: >
		Lorem     /*      ispum      */     dolor
<	Margin: >
		     [<->]                     [<->]
<	Padding: >
		            [<->]       [<->]
<
	Example: >
		3[4]5
<	Left margin: 3; left and right padding: 4; right margin: 5.

	Alignment:				*commentr-comment-alignment*

	{left}	meaning
	0	Place left part of comment to the first column.
>
		 1|>   struct foobar {
		 2|>    field1,
		 3|>      field1,
		 4|>   }

	_	Place left part of comment before the first non-white
		character.
>
		 1|   >struct foobar {
		 2|    >field1,
		 3|      >field1,
		 4|   >}
<
	|	Place left part of comment to one column and as right as
		possible.
>
		 1|   >struct foobar {
		 2|   > field1,
		 3|   >   field1,
		 4|   >}
<
	{right}	meaning
	$	Append right part of comment to the line.
>
		(assume trailing whites)

		 1|   struct foobar {    <
		 2|    field1,  <
		 3|      field1, <
		 4|   }   <
<
	<	Same as $, but remove trailing whites.
>
		 1|   struct foobar {<
		 2|    field1,<
		 3|      field1,<
		 4|   }<
<
	|	Remove trailing whites and place right part of comment to one
		column and as left as possible. Note that lines may be longer
		than 'textwidth'.
>
		 1|   struct foobar {<
		 2|    field1,       <
		 3|      field1,     <
		 4|   }              <
<
	I, >	Remove trailing whites and stretch line to 'textwidth'
		character wide by inserting spaces. When no 'textwidth' is
		specified, ">" is the same as "|", "I" is the same as "$".
>
		set &textwidth=15

		   |-------------|
		  |12345678901234567890
		 1|   struct foobar {<
		 2|    field1,   <
		 3|      field1, <
		 4|   }          <
<
	Example: >
		|$
<	The most natural way.

	Note that <Tab> charaters will be split into spaces where necessary.

------------------------------------------------------------------------------
Comment string					*commentr-comment-string*

It is just like 'commentstring' with some added features. It is a
comma-separated list of commenting alternatives. Each alternative consits of:
	[{flags}...][{lalign}]{format}[{ralign}][,,{transform}...]

{flags}:
  \=x	Group to be use for the current and further
	comments. Internally, "\=d" used for documentation and
	"\=m" for module comments.

{lalign}:
  \0 \^ Comment must begin on the first column.

  \_	Comment must begin on the first non-whitespace column.

{format}:
	Format of comment. "%s" will be replaced with the
	comment text. If omitted, format will be treated like if "%s" would be
	appended to the end of {format}.  Example: >
		//%s
		//
<	means the same format.

	Escape sequences:
	  \n	Line break.
		Note that one-one additional line break needed on both sides
		to separate custom text from real comment start and end
		markers.

	Example: >
		/*\nStart:\nSecond line\nThird line%sLast line\n*/
<		/*Start:
		Second line
		Third line
		...
		Last line*/

{ralign}:
  \$	Comment must end at the last column. If right part of comment string
	is empty, it specifies a line comment.

  \_	Comment must end at the last non-whitespace column,
	i.e. optional whitespace can follow it.  For formats without right
	sides (e.g "//%s"), it defaults to "\$", otherwise no requirements
	will be specified.

{transform}:
  x/{sub1}/{sub2}/
	Swaps {sub1} and {sub2}: Substitutes {sub1}
	with {sub2} when commenting, and {sub2} with {sub1} when uncommenting.
	{sub1} and {sub2} are "\" escaped and passed to the regex engine with
	'noignorecase' and "very nomagic" flags ("\C\V").

  s/{pat}/{sub}/
	Substitute {pat} with {sub} only when commenting.

  S/{pat}/{sub}/
	Substitute {pat} with {sub} only when uncommenting.

Optional whitespace can be inserted between {transform} sequences. Any other
character can be used as a separator instead of "/" in {transform}.

Examples: >
	\=d\_<<%s>>\_,,  x|>>|AA|
<	Specifies a documentation comment that must spawn through the whole
	line with optional whitespace surrounding it. When commenting, every
	occurence of ">>" will be replaced with "AA". On uncommenting it will
	be undoed.

	Note that for one-way transformation use "s" or "S". It can be
	used to build regexes to nest unnestable comments.

See "autoload/commentr.vim" for more examples.

==============================================================================
CONTRIBUTIONS					*commentr-contributions*

Contributions and pull requests are welcome.

==============================================================================
LICENSE							*commentr-license*

Released under the GNU General Public License version v3.0 or later.

 vim:noet:tw=78:ts=8:ft=help:norl:nowrap
